<<code language="ocaml" | sig
  type +'a t
  type -'a u
  val wait : unit -> 'a Lwt.t * 'a Lwt.u
  val wakeup_later : 'a Lwt.u -> 'a -> unit
  val wakeup_later_exn : 'a Lwt.u -> exn -> unit
  val return : 'a -> 'a Lwt.t
  val fail : exn -> 'a Lwt.t
  val bind : 'a Lwt.t -> ('a -> 'b Lwt.t) -> 'b Lwt.t
  val catch : (unit -> 'a Lwt.t) -> (exn -> 'a Lwt.t) -> 'a Lwt.t
  val finalize : (unit -> 'a Lwt.t) -> (unit -> unit Lwt.t) -> 'a Lwt.t
  val try_bind :
    (unit -> 'a Lwt.t) -> ('a -> 'b Lwt.t) -> (exn -> 'b Lwt.t) -> 'b Lwt.t
  val dont_wait : (unit -> unit Lwt.t) -> (exn -> unit) -> unit
  val async : (unit -> unit Lwt.t) -> unit
  val async_exception_hook : (exn -> unit) Stdlib.ref
  val both : 'a Lwt.t -> 'b Lwt.t -> ('a * 'b) Lwt.t
  val join : unit Lwt.t list -> unit Lwt.t
  val all : 'a Lwt.t list -> 'a list Lwt.t
  val pick : 'a Lwt.t list -> 'a Lwt.t
  val choose : 'a Lwt.t list -> 'a Lwt.t
  val npick : 'a Lwt.t list -> 'a list Lwt.t
  val nchoose : 'a Lwt.t list -> 'a list Lwt.t
  val nchoose_split : 'a Lwt.t list -> ('a list * 'a Lwt.t list) Lwt.t
  exception Canceled
  val task : unit -> 'a Lwt.t * 'a Lwt.u
  val cancel : 'a Lwt.t -> unit
  val on_cancel : 'a Lwt.t -> (unit -> unit) -> unit
  val protected : 'a Lwt.t -> 'a Lwt.t
  val no_cancel : 'a Lwt.t -> 'a Lwt.t
  val wrap_in_cancelable : 'a Lwt.t -> 'a Lwt.t
  val map : ('a -> 'b) -> 'a Lwt.t -> 'b Lwt.t
  val on_success : 'a Lwt.t -> ('a -> unit) -> unit
  val on_failure : 'a Lwt.t -> (exn -> unit) -> unit
  val on_termination : 'a Lwt.t -> (unit -> unit) -> unit
  val on_any : 'a Lwt.t -> ('a -> unit) -> (exn -> unit) -> unit
  module Infix :
    sig
      val ( >>= ) : 'a Lwt.t -> ('a -> 'b Lwt.t) -> 'b Lwt.t
      val ( >|= ) : 'a Lwt.t -> ('a -> 'b) -> 'b Lwt.t
      val ( <&> ) : unit Lwt.t -> unit Lwt.t -> unit Lwt.t
      val ( <?> ) : 'a Lwt.t -> 'a Lwt.t -> 'a Lwt.t
      val ( =<< ) : ('a -> 'b Lwt.t) -> 'a Lwt.t -> 'b Lwt.t
      val ( =|< ) : ('a -> 'b) -> 'a Lwt.t -> 'b Lwt.t
      module Let_syntax :
        sig
          val return : 'a -> 'a Lwt.t
          val map : 'a Lwt.t -> f:('a -> 'b) -> 'b Lwt.t
          val bind : 'a Lwt.t -> f:('a -> 'b Lwt.t) -> 'b Lwt.t
          val both : 'a Lwt.t -> 'b Lwt.t -> ('a * 'b) Lwt.t
          module Open_on_rhs : sig end
        end
    end
  module Let_syntax :
    sig
      module Let_syntax :
        sig
          val return : 'a -> 'a Lwt.t
          val map : 'a Lwt.t -> f:('a -> 'b) -> 'b Lwt.t
          val bind : 'a Lwt.t -> f:('a -> 'b Lwt.t) -> 'b Lwt.t
          val both : 'a Lwt.t -> 'b Lwt.t -> ('a * 'b) Lwt.t
          module Open_on_rhs : sig end
        end
    end
  module Syntax :
    sig
      val ( let* ) : 'a Lwt.t -> ('a -> 'b Lwt.t) -> 'b Lwt.t
      val ( and* ) : 'a Lwt.t -> 'b Lwt.t -> ('a * 'b) Lwt.t
      val ( let+ ) : 'a Lwt.t -> ('a -> 'b) -> 'b Lwt.t
      val ( and+ ) : 'a Lwt.t -> 'b Lwt.t -> ('a * 'b) Lwt.t
    end
  val return_unit : unit Lwt.t
  val return_none : 'a option Lwt.t
  val return_nil : 'a list Lwt.t
  val return_true : bool Lwt.t
  val return_false : bool Lwt.t
  type 'a result = ('a, exn) Result.result
  val of_result : 'a Lwt.result -> 'a Lwt.t
  val wakeup_later_result : 'a Lwt.u -> 'a Lwt.result -> unit
  type 'a state = Return of 'a | Fail of exn | Sleep
  val state : 'a Lwt.t -> 'a Lwt.state
  type 'a key
  val new_key : unit -> 'a Lwt.key
  val get : 'a Lwt.key -> 'a option
  val with_value : 'a Lwt.key -> 'a option -> (unit -> 'b) -> 'b
  val wakeup : 'a Lwt.u -> 'a -> unit
  val wakeup_exn : 'a Lwt.u -> exn -> unit
  val wakeup_result : 'a Lwt.u -> 'a Lwt.result -> unit
  val make_value : 'a -> 'a Lwt.result
  val make_error : exn -> 'a Lwt.result
  val waiter_of_wakener : 'a Lwt.u -> 'a Lwt.t
  val add_task_r : 'a Lwt.u Lwt_sequence.t -> 'a Lwt.t
  val add_task_l : 'a Lwt.u Lwt_sequence.t -> 'a Lwt.t
  val pause : unit -> unit Lwt.t
  val wakeup_paused : unit -> unit
  val paused_count : unit -> int
  val register_pause_notifier : (int -> unit) -> unit
  val abandon_paused : unit -> unit
  val wrap : (unit -> 'a) -> 'a Lwt.t
  val wrap1 : ('a -> 'b) -> 'a -> 'b Lwt.t
  val wrap2 : ('a -> 'b -> 'c) -> 'a -> 'b -> 'c Lwt.t
  val wrap3 : ('a -> 'b -> 'c -> 'd) -> 'a -> 'b -> 'c -> 'd Lwt.t
  val wrap4 :
    ('a -> 'b -> 'c -> 'd -> 'e) -> 'a -> 'b -> 'c -> 'd -> 'e Lwt.t
  val wrap5 :
    ('a -> 'b -> 'c -> 'd -> 'e -> 'f) ->
    'a -> 'b -> 'c -> 'd -> 'e -> 'f Lwt.t
  val wrap6 :
    ('a -> 'b -> 'c -> 'd -> 'e -> 'f -> 'g) ->
    'a -> 'b -> 'c -> 'd -> 'e -> 'f -> 'g Lwt.t
  val wrap7 :
    ('a -> 'b -> 'c -> 'd -> 'e -> 'f -> 'g -> 'h) ->
    'a -> 'b -> 'c -> 'd -> 'e -> 'f -> 'g -> 'h Lwt.t
  val return_some : 'a -> 'a option Lwt.t
  val return_ok : 'a -> ('a, 'b) Result.result Lwt.t
  val return_error : 'e -> ('a, 'e) Result.result Lwt.t
  val fail_with : string -> 'a Lwt.t
  val fail_invalid_arg : string -> 'a Lwt.t
  val ( >>= ) : 'a Lwt.t -> ('a -> 'b Lwt.t) -> 'b Lwt.t
  val ( >|= ) : 'a Lwt.t -> ('a -> 'b) -> 'b Lwt.t
  val ( <?> ) : 'a Lwt.t -> 'a Lwt.t -> 'a Lwt.t
  val ( <&> ) : unit Lwt.t -> unit Lwt.t -> unit Lwt.t
  val ( =<< ) : ('a -> 'b Lwt.t) -> 'a Lwt.t -> 'b Lwt.t
  val ( =|< ) : ('a -> 'b) -> 'a Lwt.t -> 'b Lwt.t
  val is_sleeping : 'a Lwt.t -> bool
  val ignore_result : 'a Lwt.t -> unit
  val poll : 'a Lwt.t -> 'a option
  val apply : ('a -> 'b Lwt.t) -> 'a -> 'b Lwt.t
  val backtrace_bind :
    (exn -> exn) -> 'a Lwt.t -> ('a -> 'b Lwt.t) -> 'b Lwt.t
  val backtrace_catch :
    (exn -> exn) -> (unit -> 'a Lwt.t) -> (exn -> 'a Lwt.t) -> 'a Lwt.t
  val backtrace_finalize :
    (exn -> exn) -> (unit -> 'a Lwt.t) -> (unit -> unit Lwt.t) -> 'a Lwt.t
  val backtrace_try_bind :
    (exn -> exn) ->
    (unit -> 'a Lwt.t) -> ('a -> 'b Lwt.t) -> (exn -> 'b Lwt.t) -> 'b Lwt.t
  val abandon_wakeups : unit -> unit
  val debug_state_is : 'a Lwt.state -> 'a Lwt.t -> bool Lwt.t
end >>