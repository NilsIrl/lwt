<html><head><title> Lwt manual </title><meta charset="utf8"/><meta content="width=device-width, initial-scale=1" name="viewport"/><link rel="stylesheet" href="https://ocsigen.org/css/style.css"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/themes/prism.min.css"/><script type="text/javascript" src="https://ocsigen.org/js/client.js">
//<![CDATA[

//]]>
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/components/prism-core.min.js">
//<![CDATA[

//]]>
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/components/prism-ocaml.min.js">
//<![CDATA[

//]]>
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/components/prism-clike.min.js">
//<![CDATA[

//]]>
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/components/prism-reason.min.js">
//<![CDATA[

//]]>
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/components/prism-javascript.min.js">
//<![CDATA[

//]]>
</script></head><body class="manual lwt"><div class="project-page"><div class="page-header"><p class="logo-ocsigen"><a href=".././../../" class="ocsimore_phrasing_link"><img src=".././../../img/ocsigen-white.svg" alt="Ocsigen"/></a>
</p><p class="logo-subproject">Lwt</p><div class="mainmenu"><p class="mainmenu-home"><a href=".././../../" class="ocsimore_phrasing_link">Home</a></p><p class="mainmenu-doc"><a href=".././../../tuto/" class="ocsimore_phrasing_link">Doc</a></p><p><a href=".././../../eliom/" class="ocsimore_phrasing_link">Eliom</a></p><p><a href=".././../../js_of_ocaml/" class="ocsimore_phrasing_link">Js_of_ocaml</a></p><p class="mainmenu-current"><a href=".././../../lwt/" class="ocsimore_phrasing_link">Lwt</a></p><p><a href=".././../../tyxml/" class="ocsimore_phrasing_link">Tyxml</a></p><p><a href=".././../../ocsigen-start/" class="ocsimore_phrasing_link">Start</a></p></div><form id="googlesearch" action="https://google.com/search"><input name="q" id="gsearch-box" placeholder="Search using Google"/><label for="gsearch-box"><img src="/img/search.svg" alt="" id="gsearch-icon"/></label><input type="submit" id="gsearch-submit" onclick="document.getElementById('gsearch-box').value += ' site:ocsigen.org';"/></form><aside class="how-drawer"><input id="how-drawer-toggle" type="checkbox"/><label for="how-drawer-toggle" id="how-drawer-label"><span class="how-drawer-icon"></span></label><nav class="how-drawer-content"><ul class="drawermainmenu"><li class="drawermainmenu-home"><a href=".././../../" class="ocsimore_phrasing_link">Home</a>
</li><li class="drawermainmenu-doc"><a href=".././../../tuto/" class="ocsimore_phrasing_link">Doc</a>
</li><li class="drawermainmenu-project"><a href=".././../../eliom/" class="ocsimore_phrasing_link">Eliom</a>
</li><li class="drawermainmenu-project"><a href=".././../../js_of_ocaml/" class="ocsimore_phrasing_link">Js_of_ocaml</a>
</li><li class="drawermainmenu-project"><a href=".././../../ocsigenserver/" class="ocsimore_phrasing_link">Server</a>
</li><li class="drawermainmenu-project"><a href=".././../../lwt/" class="ocsimore_phrasing_link">Lwt</a>
</li><li class="drawermainmenu-project"><a href=".././../../tyxml/" class="ocsimore_phrasing_link">Tyxml</a>
</li><li class="drawermainmenu-project"><a href=".././../../ocsigen-toolkit/" class="ocsimore_phrasing_link">Toolkit</a>
</li><li class="drawermainmenu-project"><a href=".././../../ocsigen-start/" class="ocsimore_phrasing_link">Start</a>
</li><li class="drawermainmenu-project"><a href=".././../../html_of_wiki/" class="ocsimore_phrasing_link">html_of_wiki</a>
</li><li class="drawermainmenu-project"><a href=".././../../deriving/" class="ocsimore_phrasing_link">deriving</a>
</li><li class="drawermainmenu-project"><a href=".././../../ocsimore/" class="ocsimore_phrasing_link">Ocsimore (<em>deprecated</em>)</a>
</li><li class="drawermainmenu-page"><a href=".././../../projects" class="ocsimore_phrasing_link">Other projects</a>
</li><li class="drawermainmenu-page"><a href=".././../../papers" class="ocsimore_phrasing_link">Research papers</a>
</li><li class="drawermainmenu-page"><a href=".././../../credits" class="ocsimore_phrasing_link">Who does Ocsigen?</a>
</li><li class="drawermainmenu-page"><a href=".././../../contributing" class="ocsimore_phrasing_link">Contributing</a>
</li><li class="drawermainmenu-page"><a href=".././../../blog" class="ocsimore_phrasing_link">Blog</a>
</li><li class="drawermainmenu-page"><a href=".././../../install" class="ocsimore_phrasing_link">Installation</a>
</li><li class="drawermainmenu-page"><a href="https://github.com/ocsigen" class="ocsimore_phrasing_link">Source code</a>
</li></ul><nav class="how-doctree"><h1> Lwt</h1><h2><a href="manual" class="ocsimore_phrasing_link">Overview</a></h2><h1>Lwt - API Reference</h1><h2>Core library</h2><h3><a href=".././api/Lwt" class="ocsimore_phrasing_link">Lwt</a></h3><h3><a href=".././api/Lwt_condition" class="ocsimore_phrasing_link">Lwt_condition</a></h3><h3><a href=".././api/Lwt_list" class="ocsimore_phrasing_link">Lwt_list</a></h3><h3><a href=".././api/Lwt_mutex" class="ocsimore_phrasing_link">Lwt_mutex</a></h3><h3><a href=".././api/Lwt_mvar" class="ocsimore_phrasing_link">Lwt_mvar</a></h3><h3><a href=".././api/Lwt_pool" class="ocsimore_phrasing_link">Lwt_pool</a></h3><h3><a href=".././api/Lwt_stream" class="ocsimore_phrasing_link">Lwt_stream</a></h3><h3><a href=".././api/Lwt_switch" class="ocsimore_phrasing_link">Lwt_switch</a></h3><h3><a href=".././api/Lwt_sequence" class="ocsimore_phrasing_link">Lwt_sequence</a></h3><h3><a href=".././api/Lwt_pqueue" class="ocsimore_phrasing_link">Lwt_pqueue</a></h3><h2>Logger</h2><h3><a href=".././api/Lwt_log_core" class="ocsimore_phrasing_link">Lwt_log_core</a></h3><h2>Unix bindings</h2><h3><a href=".././api/Lwt_daemon" class="ocsimore_phrasing_link">Lwt_daemon</a></h3><h3><a href=".././api/Lwt_gc" class="ocsimore_phrasing_link">Lwt_gc</a></h3><h3><a href=".././api/Lwt_io" class="ocsimore_phrasing_link">Lwt_io</a></h3><h3><a href=".././api/Lwt_log" class="ocsimore_phrasing_link">Lwt_log</a></h3><h3><a href=".././api/Lwt_main" class="ocsimore_phrasing_link">Lwt_main</a></h3><h3><a href=".././api/Lwt_engine" class="ocsimore_phrasing_link">Lwt_engine</a></h3><h3><a href=".././api/Lwt_process" class="ocsimore_phrasing_link">Lwt_process</a></h3><h3><a href=".././api/Lwt_throttle" class="ocsimore_phrasing_link">Lwt_throttle</a></h3><h3><a href=".././api/Lwt_timeout" class="ocsimore_phrasing_link">Lwt_timeout</a></h3><h3><a href=".././api/Lwt_unix" class="ocsimore_phrasing_link">Lwt_unix</a></h3><h3><a href=".././api/Lwt_bytes" class="ocsimore_phrasing_link">Lwt_bytes</a></h3><h3><a href=".././api/Lwt_sys" class="ocsimore_phrasing_link">Lwt_sys</a></h3><h2>Reactive programming helpers</h2><h3><a href=".././api/Lwt_react" class="ocsimore_phrasing_link">Lwt_react</a></h3><h2>PPX syntax extension</h2><h3><a href=".././api/Ppx_lwt" class="ocsimore_phrasing_link">Ppx_lwt</a></h3><h2>Miscellaneous</h2><h3><a href=".././api/Lwt_glib" class="ocsimore_phrasing_link">Lwt_glib</a></h3><h3><a href=".././api/Lwt_preemptive" class="ocsimore_phrasing_link">Lwt_preemptive</a></h3><h3><a href=".././api/Lwt_ssl" class="ocsimore_phrasing_link">Lwt_ssl</a></h3><h2>Camlp4 syntax extensions</h2><h3><a href=".././api/Pa_lwt" class="ocsimore_phrasing_link">Pa_lwt</a></h3><h3><a href=".././api/Pa_lwt_log" class="ocsimore_phrasing_link">Pa_lwt_log</a></h3><h2>Index</h2><h3> <span><a href=".././api/index_types">Index of types</a></span></h3><h3> <span><a href=".././api/index_exceptions">Index of exceptions</a></span></h3><h3> <span><a href=".././api/index_values">Index of values</a></span></h3><h3> <span><a href=".././api/index_attributes">Index of class attributes</a></span></h3><h3> <span><a href=".././api/index_methods">Index of class methods</a></span></h3><h3> <span><a href=".././api/index_classes">Index of classes</a></span></h3><h3> <span><a href=".././api/index_class_types">Index of class types</a></span></h3><h3> <span><a href=".././api/index_modules">Index of modules</a></span></h3><h3> <span><a href=".././api/index_module_types">Index of module types</a></span></h3></nav></nav></aside></div><p class="reasonwarning">Warning: Reason support is experimental.
We are looking for beta-tester and contributors.
</p><button id="reason">Switch to </button><div class="twocols"><nav class="leftcol">Version <select class="how-versions" onchange="location = this.value;"><option value=".././../1.0.0/manual/manual">1.0.0</option><option value=".././../1.1.0/manual/manual">1.1.0</option><option value=".././../2.0.0/manual/manual">2.0.0</option><option value=".././../2.1.0/manual/manual">2.1.0</option><option value=".././../2.1.1/manual/manual">2.1.1</option><option value=".././../2.2.0/manual/manual">2.2.0</option><option value=".././../2.2.1/manual/manual">2.2.1</option><option value=".././../2.3.0/manual/manual">2.3.0</option><option value=".././../2.3.1/manual/manual">2.3.1</option><option value=".././../2.3.2/manual/manual">2.3.2</option><option value=".././../2.4.0/manual/manual">2.4.0</option><option value=".././../2.4.1/manual/manual">2.4.1</option><option value=".././../2.4.2/manual/manual">2.4.2</option><option value=".././../2.4.3/manual/manual">2.4.3</option><option value=".././../2.4.7/manual/manual">2.4.7</option><option value=".././../2.4.8/manual/manual">2.4.8</option><option value=".././../2.5.0/manual/manual">2.5.0</option><option value=".././../2.5.1/manual/manual">2.5.1</option><option value=".././../2.5.2/manual/manual">2.5.2</option><option value=".././../2.6.0/manual/manual" selected="selected">2.6.0</option><option value=".././../2.7.0/manual/manual">2.7.0</option><option value=".././../2.7.1/manual/manual">2.7.1</option><option value=".././../3.0.0/manual/manual">3.0.0</option><option value=".././../3.1.0/manual/manual">3.1.0</option><option value=".././../3.2.1/manual/manual">3.2.1</option><option value=".././../3.3.0/manual/manual">3.3.0</option><option value=".././../4.0.0/manual/manual">4.0.0</option><option value=".././../4.0.1/manual/manual">4.0.1</option><option value=".././../4.1.0/manual/manual">4.1.0</option><option value=".././../4.2.0/manual/manual">4.2.0</option><option value=".././../4.2.1/manual/manual">4.2.1</option><option value=".././../4.3.0/manual/manual">4.3.0</option><option value=".././../4.3.1/manual/manual">4.3.1</option><option value=".././../4.4.0/manual/manual">4.4.0</option><option value=".././../4.5.0/manual/manual">4.5.0</option><option value=".././../5.0.0/manual/manual">5.0.0</option><option value=".././../5.0.1/manual/manual">5.0.1</option><option value=".././../5.1.0/manual/manual">5.1.0</option><option value=".././../5.1.1/manual/manual">5.1.1</option><option value=".././../5.1.2/manual/manual">5.1.2</option><option value=".././../5.2.0/manual/manual">5.2.0</option><option value=".././../5.3.0/manual/manual">5.3.0</option><option value=".././../dev/manual/manual">dev</option></select><nav class="how-doctree"><h1> Lwt</h1><h2><a href="manual" class="ocsimore_phrasing_link">Overview</a></h2><h1>Lwt - API Reference</h1><h2>Core library</h2><h3><a href=".././api/Lwt" class="ocsimore_phrasing_link">Lwt</a></h3><h3><a href=".././api/Lwt_condition" class="ocsimore_phrasing_link">Lwt_condition</a></h3><h3><a href=".././api/Lwt_list" class="ocsimore_phrasing_link">Lwt_list</a></h3><h3><a href=".././api/Lwt_mutex" class="ocsimore_phrasing_link">Lwt_mutex</a></h3><h3><a href=".././api/Lwt_mvar" class="ocsimore_phrasing_link">Lwt_mvar</a></h3><h3><a href=".././api/Lwt_pool" class="ocsimore_phrasing_link">Lwt_pool</a></h3><h3><a href=".././api/Lwt_stream" class="ocsimore_phrasing_link">Lwt_stream</a></h3><h3><a href=".././api/Lwt_switch" class="ocsimore_phrasing_link">Lwt_switch</a></h3><h3><a href=".././api/Lwt_sequence" class="ocsimore_phrasing_link">Lwt_sequence</a></h3><h3><a href=".././api/Lwt_pqueue" class="ocsimore_phrasing_link">Lwt_pqueue</a></h3><h2>Logger</h2><h3><a href=".././api/Lwt_log_core" class="ocsimore_phrasing_link">Lwt_log_core</a></h3><h2>Unix bindings</h2><h3><a href=".././api/Lwt_daemon" class="ocsimore_phrasing_link">Lwt_daemon</a></h3><h3><a href=".././api/Lwt_gc" class="ocsimore_phrasing_link">Lwt_gc</a></h3><h3><a href=".././api/Lwt_io" class="ocsimore_phrasing_link">Lwt_io</a></h3><h3><a href=".././api/Lwt_log" class="ocsimore_phrasing_link">Lwt_log</a></h3><h3><a href=".././api/Lwt_main" class="ocsimore_phrasing_link">Lwt_main</a></h3><h3><a href=".././api/Lwt_engine" class="ocsimore_phrasing_link">Lwt_engine</a></h3><h3><a href=".././api/Lwt_process" class="ocsimore_phrasing_link">Lwt_process</a></h3><h3><a href=".././api/Lwt_throttle" class="ocsimore_phrasing_link">Lwt_throttle</a></h3><h3><a href=".././api/Lwt_timeout" class="ocsimore_phrasing_link">Lwt_timeout</a></h3><h3><a href=".././api/Lwt_unix" class="ocsimore_phrasing_link">Lwt_unix</a></h3><h3><a href=".././api/Lwt_bytes" class="ocsimore_phrasing_link">Lwt_bytes</a></h3><h3><a href=".././api/Lwt_sys" class="ocsimore_phrasing_link">Lwt_sys</a></h3><h2>Reactive programming helpers</h2><h3><a href=".././api/Lwt_react" class="ocsimore_phrasing_link">Lwt_react</a></h3><h2>PPX syntax extension</h2><h3><a href=".././api/Ppx_lwt" class="ocsimore_phrasing_link">Ppx_lwt</a></h3><h2>Miscellaneous</h2><h3><a href=".././api/Lwt_glib" class="ocsimore_phrasing_link">Lwt_glib</a></h3><h3><a href=".././api/Lwt_preemptive" class="ocsimore_phrasing_link">Lwt_preemptive</a></h3><h3><a href=".././api/Lwt_ssl" class="ocsimore_phrasing_link">Lwt_ssl</a></h3><h2>Camlp4 syntax extensions</h2><h3><a href=".././api/Pa_lwt" class="ocsimore_phrasing_link">Pa_lwt</a></h3><h3><a href=".././api/Pa_lwt_log" class="ocsimore_phrasing_link">Pa_lwt_log</a></h3><h2>Index</h2><h3> <span><a href=".././api/index_types">Index of types</a></span></h3><h3> <span><a href=".././api/index_exceptions">Index of exceptions</a></span></h3><h3> <span><a href=".././api/index_values">Index of values</a></span></h3><h3> <span><a href=".././api/index_attributes">Index of class attributes</a></span></h3><h3> <span><a href=".././api/index_methods">Index of class methods</a></span></h3><h3> <span><a href=".././api/index_classes">Index of classes</a></span></h3><h3> <span><a href=".././api/index_class_types">Index of class types</a></span></h3><h3> <span><a href=".././api/index_modules">Index of modules</a></span></h3><h3> <span><a href=".././api/index_module_types">Index of module types</a></span></h3></nav></nav><article class="rightcol"><h1> Lwt manual </h1><h2> Introduction </h2><p>When writing a program, a common developer's task is to handle IO
operations. Indeed most software interact with several different
resources, such as:
</p><ul><li> the kernel, by doing system calls
</li><li> the user, by reading the keyboard, the mouse, or any input device
</li><li> a graphical server, to build graphical user interface
</li><li> other computers, by using the network
</li><li> ...
</li></ul><p>When this list contains only one item, it is pretty easy to
handle. However as this list grows it becomes harder and harder to
make everything works together. Several choices have been proposed
to solve this problem:
</p><ul><li> using a main loop, and integrate all components we are
interacting with into this main loop.
</li><li> using preemptive system threads
</li></ul><p>Both solutions have their advantages and their drawbacks. For the
first one, it may work, but it becomes very complicated to write
a piece of asynchronous sequential code. The typical example is
graphical user interfaces freezing and not redrawing themselves
because they are waiting for some blocking part of the code to
complete.
</p><p>If you already wrote code using preemptive threads, you should know
that doing it right with threads is a hard job. Moreover system
threads consume non negligible resources, and so you can only launch
a limited number of threads at the same time. Thus this is not a
real solution.
</p><p><span class="teletype">Lwt</span> offers a new alternative. It provides very light-weight
cooperative threads; ``launching'' a thread is a very fast
operation, it does not require a new stack, a new process, or
anything else. Moreover context switches are very fast. In fact, it
is so easy that we will launch a thread for every system call. And
composing cooperative threads will allow us to write highly
asynchronous programs.
</p><p>In a first part, we will explain the concepts of <span class="teletype">Lwt</span>, then we will
describe the many sub-libraries of <span class="teletype">Lwt</span>.
</p><h2> The Lwt core library </h2><p>In this section we describe the basics of <span class="teletype">Lwt</span>. It is advised to
start an ocaml toplevel and try the given code examples. To start,
launch <span class="teletype">ocaml</span> in a terminal or in emacs with the tuareg
mode, and type:
</p><pre># #use &quot;topfind&quot;;;
# #require &quot;lwt.simple-top&quot;;;
</pre><p><span class="teletype">lwt.simple-top</span> makes sure <span class="teletype">Lwt</span> threads can run while
using the toplevel. You do not need it if you are using <span class="teletype">utop</span>.
</p><h3> Lwt concepts </h3><p>Let's take a classical function of the <span class="teletype">Pervasives</span> module:
</p><pre class=""><code class="language-ocaml translatable"># Pervasives.input_char;;
- : in_channel -&gt; char = &lt;fun&gt;</code></pre><p>This function will wait for a character to come on the given input
channel, and then return it. The problem with this function is that it is
blocking: while it is being executed, the whole program will be
blocked, and other events will not be handled until it returns.
</p><p>Now let's look at the lwt equivalent:
</p><pre class=""><code class="language-ocaml translatable"># Lwt_io.read_char;;
- : Lwt_io.input_channel -&gt; char Lwt.t = &lt;fun&gt;</code></pre><p>As you can see, it does not return a character but something of
type <span class="teletype">char Lwt.t</span>. The type <span class="teletype">'a Lwt.t</span> is the type
of threads returning a value of type <span class="teletype">'a</span>. Actually the
<span class="teletype">Lwt_io.read_char</span> will try to read a character from the
given input channel and <em>immediately</em> returns a light-weight
thread.
</p><p>Now, let's see what we can do with a <span class="teletype">Lwt</span> thread. The following
code creates a pipe, and launches a thread reading on the input side:
</p><pre class=""><code class="language-ocaml translatable"># let ic, oc = Lwt_io.pipe ();;
val ic : Lwt_io.input_channel = &lt;abstr&gt;
val oc : Lwt_io.output_channel = &lt;abstr&gt;
# let t = Lwt_io.read_char ic;;
val t : char Lwt.t = &lt;abstr&gt;</code></pre><p>We can now look at the state of our newly created thread:
</p><pre class=""><code class="language-ocaml translatable"># Lwt.state t;;
- : char Lwt.state = Lwt.Sleep</code></pre><p>A thread may be in one of the following states:
</p><ul><li> <span class="teletype">Return x</span>, which means that the thread has terminated
successfully and returned the value <span class="teletype">x</span>
</li><li> <span class="teletype">Fail exn</span>, which means that the thread has terminated,
but instead of returning a value, it failed with the exception
<span class="teletype">exn</span>
</li><li> <span class="teletype">Sleep</span>, which means that the thread is currently
sleeping and has not yet returned a value or an exception
</li></ul><p>The thread <span class="teletype">t</span> is sleeping because there is currently nothing
to read from the pipe. Let's write something:
</p><pre class=""><code class="language-ocaml translatable"># Lwt_io.write_char oc 'a';;
- : unit Lwt.t = &lt;abstr&gt;
# Lwt.state t;;
- : char Lwt.state = Lwt.Return 'a'</code></pre><p>So, after we write something, the reading thread has been awoken and
has returned the value <span class="teletype">'a'</span>.
</p><h3> Primitives for thread creation </h3><p>There are several primitives for creating <span class="teletype">Lwt</span> threads. These
functions are located in the module <span class="teletype">Lwt</span>.
</p><p>Here are the main primitives:
</p><ul><li> <span class="teletype">Lwt.return : 'a -&gt; 'a Lwt.t</span>
<br/>
creates a thread which has already terminated and returned a value
</li><li> <span class="teletype">Lwt.fail : exn -&gt; 'a Lwt.t</span>
<br/>
creates a thread which has already terminated and failed with an
exception
</li><li> <span class="teletype">Lwt.wait : unit -&gt; 'a Lwt.t * 'a Lwt.u</span>
<br/>
creates a sleeping thread and returns this thread plus a wakener (of
type <span class="teletype">'a Lwt.u</span>) which must be used to wakeup the sleeping
thread.
</li></ul><p>To wake up a sleeping thread, you must use one of the following
functions:
</p><ul><li> <span class="teletype">Lwt.wakeup : 'a Lwt.u -&gt; 'a -&gt; unit</span>
<br/>
wakes up the thread with a value.
</li><li> <span class="teletype">Lwt.wakeup_exn : 'a Lwt.u -&gt; exn -&gt; unit</span>
<br/>
wakes up the thread with an exception.
</li></ul><p>Note that it is an error to wakeup the same thread twice. <span class="teletype">Lwt</span>
will raise <span class="teletype">Invalid_argument</span> if you try to do so.
</p><p>With this information, try to guess the result of each of the
following expression:
</p><pre class=""><code class="language-ocaml translatable"># Lwt.state (Lwt.return 42);;
# Lwt.state (Lwt.fail Exit);;
# let waiter, wakener = Lwt.wait ();;
# Lwt.state waiter;;
# Lwt.wakeup wakener 42;;
# Lwt.state waiter;;
# let waiter, wakener = Lwt.wait ();;
# Lwt.state waiter;;
# Lwt.wakeup_exn wakener Exit;;
# Lwt.state waiter;;</code></pre><h4> Primitives for thread composition </h4><p>The most important operation you need to know is <span class="teletype">bind</span>:
</p><pre class=""><code class="language-ocaml translatable">val bind : 'a Lwt.t -&gt; ('a -&gt; 'b Lwt.t) -&gt; 'b Lwt.t</code></pre><p><span class="teletype">bind t f</span> creates a thread which waits for <span class="teletype">t</span> to
terminate, then passes the result to <span class="teletype">f</span>. If <span class="teletype">t</span> is a
sleeping thread, then <span class="teletype">bind t f</span> will be a sleeping thread too,
until <span class="teletype">t</span> terminates. If <span class="teletype">t</span> fails, then the resulting
thread will fail with the same exception. For example, consider the
following expression:
</p><pre class=""><code class="language-ocaml translatable">Lwt.bind
  (Lwt_io.read_line Lwt_io.stdin)
  (fun str -&gt; Lwt_io.printlf &quot;You typed %S&quot; str)</code></pre><p>This code will first wait for the user to enter a line of text, then
print a message on the standard output.
</p><p>Similarly to <span class="teletype">bind</span>, there is a function to handle the case
when <span class="teletype">t</span> fails:
</p><pre class=""><code class="language-ocaml translatable">val catch : (unit -&gt; 'a Lwt.t) -&gt; (exn -&gt; 'a Lwt.t) -&gt; 'a Lwt.t</code></pre><p><span class="teletype">catch f g</span> will call <span class="teletype">f ()</span>, then waits for its
termination, and if it fails with an exception <span class="teletype">exn</span>, calls
<span class="teletype">g exn</span> to handle it. Note that both exceptions raised with
<span class="teletype">Pervasives.raise</span> and <span class="teletype">Lwt.fail</span> are caught by
<span class="teletype">catch</span>.
</p><h4> Cancelable threads </h4><p>In some case, we may want to cancel a thread. For example, because it
has not terminated after a timeout. This can be done with cancelable
threads. To create a cancelable thread, you must use the
<span class="teletype">Lwt.task</span> function:
</p><pre class=""><code class="language-ocaml translatable">val task : unit -&gt; 'a Lwt.t * 'a Lwt.u</code></pre><p>It has the same semantics as <span class="teletype">Lwt.wait</span> except that the
sleeping thread can be canceled with <span class="teletype">Lwt.cancel</span>:
</p><pre class=""><code class="language-ocaml translatable">val cancel : 'a Lwt.t -&gt; unit</code></pre><p>The thread will then fail with the exception
<span class="teletype">Lwt.Canceled</span>. To execute a function when the thread is
canceled, you must use <span class="teletype">Lwt.on_cancel</span>:
</p><pre class=""><code class="language-ocaml translatable">val on_cancel : 'a Lwt.t -&gt; (unit -&gt; unit) -&gt; unit</code></pre><p>Note that it is also possible to cancel a thread which has not been
created with <span class="teletype">Lwt.task</span>. In this case, the deepest cancelable
thread connected with the given thread will be cancelled.
</p><p>For example, consider the following code:
</p><pre class=""><code class="language-ocaml translatable"># let waiter, wakener = Lwt.task ();;
val waiter : '_a Lwt.t = &lt;abstr&gt;
val wakener : '_a Lwt.u = &lt;abstr&gt;
# let t = Lwt.bind waiter (fun x -&gt; Lwt.return (x + 1));;
val t : int Lwt.t = &lt;abstr&gt;</code></pre><p>Here, cancelling <span class="teletype">t</span> will in fact cancel <span class="teletype">waiter</span>.
<span class="teletype">t</span> will then fail with the exception <span class="teletype">Lwt.Canceled</span>:
</p><pre class=""><code class="language-ocaml translatable"># Lwt.cancel t;;
- : unit = ()
# Lwt.state waiter;;
- : int Lwt.state = Lwt.Fail Lwt.Canceled
# Lwt.state t;;
- : int Lwt.state = Lwt.Fail Lwt.Canceled</code></pre><p>By the way, it is possible to prevent a thread from being canceled
by using the function <span class="teletype">Lwt.protected</span>:
</p><pre class=""><code class="language-ocaml translatable">val protected : 'a Lwt.t -&gt; 'a Lwt.t</code></pre><p>Canceling <span class="teletype">(proctected t)</span> will have no effect on <span class="teletype">t</span>.
</p><h4> Primitives for multi-thread composition </h4><p>We now show how to compose several concurrent threads. The
main functions for this are in the <span class="teletype">Lwt</span> module: <span class="teletype">join</span>,
<span class="teletype">choose</span> and <span class="teletype">pick</span>.
</p><p>The first one, <span class="teletype">join</span> takes a list of threads and waits for all
of them to terminate:
</p><pre class=""><code class="language-ocaml translatable">val join : unit Lwt.t list -&gt; unit Lwt.t</code></pre><p>Moreover, if at least one thread fails, <span class="teletype">join l</span> will fail with
the same exception as the first to fail, after all threads terminate.
</p><p>Similarly <span class="teletype">choose</span> waits for at least one thread to
terminate, then returns the same value or exception:
</p><pre class=""><code class="language-ocaml translatable">val choose : 'a Lwt.t list -&gt; 'a Lwt.t</code></pre><p>For example:
</p><pre class=""><code class="language-ocaml translatable"># let waiter1, wakener1 = Lwt.wait ();;
val waiter1 : '_a Lwt.t = &lt;abstr&gt;
val wakener1 : '_a Lwt.u = &lt;abstr&gt;
# let waiter2, wakener2 = Lwt.wait ();;
val waiter2 : '_a Lwt.t = &lt;abstr&gt;
val wakener : '_a Lwt.u = &lt;abstr&gt;
# let t = Lwt.choose [waiter1; waiter2];;
val t : '_a Lwt.t = &lt;abstr&gt;
# Lwt.state t;;
- : '_a Lwt.state = Lwt.Sleep
# Lwt.wakeup wakener2 42;;
- : unit = ()
# Lwt.state t;;
- : int Lwt.state = Lwt.Return 42</code></pre><p>The last one, <span class="teletype">pick</span>, is the same as <span class="teletype">choose</span> except that it cancels
all other threads when one terminates.
</p><h4> Threads local storage </h4><p>Lwt can store variables with different values on different
threads. This is called threads local storage. For example, this can
be used to store contexts or thread identifiers. The contents of a
variable can be read with:
</p><pre class=""><code class="language-ocaml translatable">val Lwt.get : 'a Lwt.key -&gt; 'a option</code></pre><p>which takes a key to identify the variable we want to read and
returns either <span class="teletype">None</span> if the variable is not set, or
<span class="teletype">Some x</span> if it is. The value returned is the value of the
variable in the current thread.
</p><p>New keys can be created with:
</p><pre class=""><code class="language-ocaml translatable">val Lwt.new_key : unit -&gt; 'a Lwt.key</code></pre><p>To set a variable, you must use:
</p><pre class=""><code class="language-ocaml translatable">val Lwt.with_value : 'a Lwt.key -&gt; 'a option -&gt; (unit -&gt; 'b) -&gt; 'b</code></pre><p><span class="teletype">with_value key value f</span> will execute <span class="teletype">f</span> with
the binding <span class="teletype">key -&gt; value</span>. The old value associated to
<span class="teletype">key</span> is restored after <span class="teletype">f</span> terminates.
</p><p>For example, you can use local storage to store thread identifiers
and use them in logs:
</p><pre class=""><code class="language-ocaml translatable">let id_key = Lwt.new_key ()

let log msg =
  let thread_id =
    match Lwt.get id_key with
      | Some id -&gt; id
      | None -&gt; &quot;main&quot;
  in
  Lwt_io.printlf &quot;%s: %s&quot; thread_id msg

lwt () =
  Lwt.join [
    Lwt.with_value id_key (Some &quot;thread 1&quot;) (fun () -&gt; log &quot;foo&quot;);
    Lwt.with_value id_key (Some &quot;thread 2&quot;) (fun () -&gt; log &quot;bar&quot;);
  ]</code></pre><h4> Rules </h4><p><span class="teletype">Lwt</span> will always try to execute as much as possible before yielding and
switching to another cooperative thread. In order to make it work well,
you must follow the following rules:
</p><ul><li> do not write functions that may take time to complete without
using <span class="teletype">Lwt</span>,
</li><li> do not do IOs that may block, otherwise the whole program will
hang. You must instead use asynchronous IOs operations.
</li></ul><h3> The syntax extension </h3><p><span class="teletype">Lwt</span> offers two syntax extensions which increases code readability and
makes coding using <span class="teletype">Lwt</span> easier.
</p><h4> Ppx </h4><p>The Ppx syntax extension is documented <span><a href=".././api/Ppx_lwt">here</a></span>.
This syntax extension is more recent and is recommended.
</p><h4> Camlp4 </h4><p>To use it add the <span class="teletype">lwt.syntax</span> package when
compiling:
</p><pre class=""><code class="language-ocaml translatable">$ ocamlfind ocamlc -syntax camlp4o -package lwt.syntax -linkpkg -o foo foo.ml</code></pre><p>Or in the toplevel (after loading topfind):
</p><pre class=""><code class="language-ocaml translatable"># #camlp4o;;
# #require &quot;lwt.syntax&quot;;;</code></pre><p>The following constructions are added to the language:
</p><ul><li> <span class="teletype">lwt</span> <em>pattern<sub>1</sub></em> <span class="teletype">=</span> <em>expr<sub>1</sub></em> [ <span class="teletype">and</span>
<em>pattern<sub>2</sub></em> <span class="teletype">=</span> <em>expr<sub>2</sub></em> ... ] <span class="teletype">in</span> <em>expr</em>
<br/>
which is a parallel let-binding construction. For example in the
following code:
</li></ul><pre class=""><code class="language-ocaml translatable">lwt x = f () and y = g () in
expr</code></pre><p>the thread <span class="teletype">f ()</span> and <span class="teletype">g ()</span> are launched concurrently
and their results are then bound to <span class="teletype">x</span> and <span class="teletype">y</span> in the
expression <em>expr</em>.
</p><p>Of course you can also launch the two threads sequentially by
writing your code like that:
</p><pre class=""><code class="language-ocaml translatable">lwt x = f () in
lwt y = g () in
expr</code></pre><ul><li> <span class="teletype">try_lwt</span> <em>expr</em> [ <span class="teletype">with</span> <em>pattern<sub>1</sub></em>
<span class="teletype">-&gt;</span> <em>expr<sub>1</sub></em> ... ] [ <span class="teletype">finally</span> <em>expr'</em> ]
<br/>
which is the equivalent of the standard <span class="teletype">try-with</span>
construction but for <span class="teletype">Lwt</span>. Both exceptions raised by
<span class="teletype">Pervasives.raise</span> and <span class="teletype">Lwt.fail</span> are caught.
</li></ul><ul><li> <span class="teletype">for_lwt</span> <em>ident</em> <span class="teletype">=</span> <em>expr<sub>init</sub></em> ( <span class="teletype">to</span> <span class="teletype">|</span>
<span class="teletype">downto</span> ) <em>expr<sub>final</sub></em> <span class="teletype">do</span> <em>expr</em>
<span class="teletype">done</span>
<br/>
which is the equivalent of the standard <span class="teletype">for</span> construction
but for <span class="teletype">Lwt</span>.
</li></ul><ul><li> <span class="teletype">raise_lwt</span> <em>exn</em>
<br/>
which is the same as <span class="teletype">Lwt.fail</span> <em>exn</em> but with backtrace support.
</li></ul><h4> Correspondence table </h4><p>You might appreciate the following table to write code using lwt:
</p><table><tr><th> without <span class="teletype">Lwt</span>                                                               </th><th> with <span class="teletype">Lwt</span>                                                                      </th></tr><tr><td>                                                                                  </td><td>                                                                                      </td></tr><tr><td> <span class="teletype">let</span> <em>pattern<sub>1</sub></em> <span class="teletype">=</span> <em>expr<sub>1</sub></em>                                 </td><td> <span class="teletype">lwt</span> <em>pattern<sub>1</sub></em> <span class="teletype">=</span> <em>expr<sub>1</sub></em>                                     </td></tr><tr><td> <span class="teletype">and</span> <em>pattern<sub>2</sub></em> <span class="teletype">=</span> <em>expr<sub>2</sub></em>                                 </td><td> <span class="teletype">and</span> <em>pattern<sub>2</sub></em> <span class="teletype">=</span> <em>expr<sub>2</sub></em>                                     </td></tr><tr><td> ...                                                                              </td><td> ...                                                                                  </td></tr><tr><td> <span class="teletype">and</span> <em>pattern<sub>n</sub></em> <span class="teletype">=</span> <em>expr<sub>n</sub></em> <span class="teletype">in</span>                        </td><td> <span class="teletype">and</span> <em>pattern<sub>n</sub></em> <span class="teletype">=</span> <em>expr<sub>n</sub></em> <span class="teletype">in</span>                            </td></tr><tr><td> <em>expr</em>                                                                         </td><td> <em>expr</em>                                                                             </td></tr><tr><td>                                                                                  </td><td>                                                                                      </td></tr><tr><td> <span class="teletype">try</span>                                                                        </td><td> <span class="teletype">try_lwt</span>                                                                        </td></tr><tr><td> <em> expr</em>                                                                        </td><td> <em> expr</em>                                                                            </td></tr><tr><td> <span class="teletype">with</span>                                                                       </td><td> <span class="teletype">with</span>                                                                           </td></tr><tr><td> <em> </em> <span class="teletype">|</span> <em>pattern<sub>1</sub></em> <span class="teletype">-&gt;</span> <em>expr<sub>1</sub></em>                            </td><td> <em> </em> <span class="teletype">|</span> <em>pattern<sub>1</sub></em> <span class="teletype">-&gt;</span> <em>expr<sub>1</sub></em>                                </td></tr><tr><td> <em> </em> <span class="teletype">|</span> <em>pattern<sub>2</sub></em> <span class="teletype">-&gt;</span> <em>expr<sub>2</sub></em>                            </td><td> <em> </em> <span class="teletype">|</span> <em>pattern<sub>2</sub></em> <span class="teletype">-&gt;</span> <em>expr<sub>2</sub></em>                                </td></tr><tr><td> <em> </em> ...                                                                        </td><td> <em> </em> ...                                                                            </td></tr><tr><td> <em> </em> <span class="teletype">|</span> <em>pattern<sub>n</sub></em> <span class="teletype">-&gt;</span> <em>expr<sub>n</sub></em>                            </td><td> <em> </em> <span class="teletype">|</span> <em>pattern<sub>n</sub></em> <span class="teletype">-&gt;</span> <em>expr<sub>n</sub></em>                                </td></tr><tr><td>                                                                                  </td><td>                                                                                      </td></tr><tr><td> <span class="teletype">for</span> <em>ident</em> <span class="teletype">=</span> <em>expr<sub>init</sub></em> <span class="teletype">to</span> <em>expr<sub>final</sub></em> <span class="teletype">do</span> </td><td> <span class="teletype">for_lwt</span> <em>ident</em> <span class="teletype">=</span> <em>expr<sub>init</sub></em> <span class="teletype">to</span> <em>expr<sub>final</sub></em> <span class="teletype">do</span> </td></tr><tr><td> <em> expr</em>                                                                        </td><td> <em> expr</em>                                                                            </td></tr><tr><td> <span class="teletype">done</span>                                                                       </td><td> <span class="teletype">done</span>                                                                           </td></tr><tr><td>                                                                                  </td><td>                                                                                      </td></tr><tr><td> <span class="teletype">raise</span> <em>exn</em>                                                              </td><td> <span class="teletype">raise_lwt</span> <em>exn</em>                                                              </td></tr><tr><td>                                                                                  </td><td>                                                                                      </td></tr><tr><td> <span class="teletype">assert</span> <em>expr</em>                                                            </td><td> <span class="teletype">assert_lwt</span> <em>expr</em>                                                            </td></tr><tr><td>                                                                                  </td><td>                                                                                      </td></tr><tr><td> <span class="teletype">match</span> <em>expr</em> <span class="teletype">with</span>                                                  </td><td> <span class="teletype">match_lwt</span> <em>expr</em> <span class="teletype">with</span>                                                  </td></tr><tr><td> <em> </em> <span class="teletype">|</span> <em>pattern<sub>1</sub></em> <span class="teletype">-&gt;</span> <em>expr<sub>1</sub></em>                            </td><td> <em> </em> <span class="teletype">|</span> <em>pattern<sub>1</sub></em> <span class="teletype">-&gt;</span> <em>expr<sub>1</sub></em>                                </td></tr><tr><td> <em> </em> <span class="teletype">|</span> <em>pattern<sub>2</sub></em> <span class="teletype">-&gt;</span> <em>expr<sub>2</sub></em>                            </td><td> <em> </em> <span class="teletype">|</span> <em>pattern<sub>2</sub></em> <span class="teletype">-&gt;</span> <em>expr<sub>2</sub></em>                                </td></tr><tr><td> <em> </em> ...                                                                        </td><td> <em> </em> ...                                                                            </td></tr><tr><td> <em> </em> <span class="teletype">|</span> <em>pattern<sub>n</sub></em> <span class="teletype">-&gt;</span> <em>expr<sub>n</sub></em>                            </td><td> <em> </em> <span class="teletype">|</span> <em>pattern<sub>n</sub></em> <span class="teletype">-&gt;</span> <em>expr<sub>n</sub></em>                                </td></tr><tr><td>                                                                                  </td><td>                                                                                      </td></tr><tr><td> <span class="teletype">while</span> <em>expr</em> <span class="teletype">do</span>                                                    </td><td> <span class="teletype">while_lwt</span> <em>expr</em> <span class="teletype">do</span>                                                    </td></tr><tr><td> <em> expr</em>                                                                        </td><td> <em> expr</em>                                                                            </td></tr><tr><td> <span class="teletype">done</span>                                                                       </td><td> <span class="teletype">done</span>                                                                           </td></tr></table><h3> Backtrace support </h3><p>If an exception is raised inside an Lwt thread, the backtrace provided by OCaml
will not be very useful. It will end inside the Lwt scheduler instead of
continuing into the code that started the thread. To avoid this, and get good
backtraces from Lwt, use one of the syntax extensions in debug mode.
</p><p>In debug mode, the <span class="teletype">lwt</span> and <span class="teletype">let%lwt</span> constructs will properly
propagate backtraces.
</p><p>In the <span><a href=".././api/Ppx_lwt">ppx syntax extension</a></span>, the debug mode is
enabled by default. This has a small performance impact, so you can disable it
by passing <span class="teletype">-no-debug</span>.
</p><p>In the <span class="teletype">camlp4 syntax extension</span>, you need to pass the <span class="teletype">-lwt-debug</span> switch:
</p><pre>$ ocamlfind ocamlc -syntax camlp4o -package lwt.syntax \
    -ppopt -lwt-debug -linkpkg -o foo foo.ml
</pre><p>As always, to get backtraces from an OCaml program, you need to either declare
the environment variable <span class="teletype">OCAMLRUNPARAM=b</span> or call
<span class="teletype">Printexc.record_backtrace true</span> at the start of your program.
</p><h3> Other modules of the core library </h3><p>The core library contains several modules that only depend on
<span class="teletype">Lwt</span>. The following naming convention is used in <span class="teletype">Lwt</span>: when a
function takes as argument a function returning a thread that is going
to be executed sequentially, it is suffixed with ``<span class="teletype">_s</span>''. And
when it is going to be executed concurrently, it is suffixed with
``<span class="teletype">_p</span>''. For example, in the <span class="teletype">Lwt_list</span> module we have:
</p><pre class=""><code class="language-ocaml translatable">val map_s : ('a -&gt; 'b Lwt.t) -&gt; 'a list -&gt; 'b list Lwt.t
val map_p : ('a -&gt; 'b Lwt.t) -&gt; 'a list -&gt; 'b list Lwt.t</code></pre><h4> Mutexes </h4><p><span class="teletype">Lwt_mutex</span> provides mutexes for <span class="teletype">Lwt</span>. Its use is almost the
same as the <span class="teletype">Mutex</span> module of the thread library shipped with
OCaml. In general, programs using <span class="teletype">Lwt</span> do not need a lot of
mutexes. They are only useful for serialising operations.
</p><h4> Lists </h4><p>The <span class="teletype">Lwt_list</span> module defines iteration and scanning functions
over lists, similar to the ones of the <span class="teletype">List</span> module, but using
functions that return a thread. For example:
</p><pre class=""><code class="language-ocaml translatable">val iter_s : ('a -&gt; unit Lwt.t) -&gt; 'a list -&gt; unit Lwt.t
val iter_p : ('a -&gt; unit Lwt.t) -&gt; 'a list -&gt; unit Lwt.t</code></pre><p>In <span class="teletype">iter_s f l</span>, <span class="teletype">iter_s</span> will call f on each elements
of <span class="teletype">l</span>, waiting for completion between each element. On the
contrary, in <span class="teletype">iter_p f l</span>, <span class="teletype">iter_p</span> will call f on all
elements of <span class="teletype">l</span>, then wait for all the threads to terminate.
</p><h4> Data streams </h4><p><span class="teletype">Lwt</span> streams are used in a lot of places in <span class="teletype">Lwt</span> and its sub
libraries. They offer a high-level interface to manipulate data flows.
</p><p>A stream is an object which returns elements sequentially and
lazily. Lazily means that the source of the stream is touched only for new
elements when needed. This module contains a lot of stream
transformation, iteration, and scanning functions.
</p><p>The common way of creating a stream is by using
<span class="teletype">Lwt_stream.from</span> or by using <span class="teletype">Lwt_stream.create</span>:
</p><pre class=""><code class="language-ocaml translatable">val from : (unit -&gt; 'a option Lwt.t) -&gt; 'a Lwt_stream.t
val create : unit -&gt; 'a Lwt_stream.t * ('a option -&gt; unit)</code></pre><p>As for streams of the standard library, <span class="teletype">from</span> takes as
argument a function which is used to create new elements.
</p><p><span class="teletype">create</span> returns a function used to push new elements
into the stream and the stream which will receive them.
</p><p>For example:
</p><pre class=""><code class="language-ocaml translatable"># let stream, push = Lwt_stream.create ();;
val stream : '_a Lwt_stream.t = &lt;abstr&gt;
val push : '_a option -&gt; unit = &lt;fun&gt;
# push (Some 1);;
- : unit = ()
# push (Some 2);;
- : unit = ()
# push (Some 3);;
- : unit = ()
# Lwt.state (Lwt_stream.next stream);;
- : int Lwt.state = Lwt.Return 1
# Lwt.state (Lwt_stream.next stream);;
- : int Lwt.state = Lwt.Return 2
# Lwt.state (Lwt_stream.next stream);;
- : int Lwt.state = Lwt.Return 3
# Lwt.state (Lwt_stream.next stream);;
- : int Lwt.state = Lwt.Sleep</code></pre><p>Note that streams are consumable. Once you take an element from a
stream, it is removed from it. So, if you want to iterate two times
over a stream, you may consider ``cloning'' it, with
<span class="teletype">Lwt_stream.clone</span>. Cloned stream will return the same
elements in the same order. Consuming one will not consume the other.
For example:
</p><pre class=""><code class="language-ocaml translatable"># let s = Lwt_stream.of_list [1; 2];;
val s : int Lwt_stream.t = &lt;abstr&gt;
# let s' = Lwt_stream.clone s;;
val s' : int Lwt_stream.t = &lt;abstr&gt;
# Lwt.state (Lwt_stream.next s);;
- : int Lwt.state = Lwt.Return 1
# Lwt.state (Lwt_stream.next s);;
- : int Lwt.state = Lwt.Return 2
# Lwt.state (Lwt_stream.next s');;
- : int Lwt.state = Lwt.Return 1
# Lwt.state (Lwt_stream.next s');;
- : int Lwt.state = Lwt.Return 2</code></pre><h4> Mailbox variables </h4><p>The <span class="teletype">Lwt_mvar</span> module provides mailbox variables. A mailbox
variable, also called a ``mvar'', is a cell which may contain 0 or 1
element. If it contains no elements, we say that the mvar is empty,
if it contains one, we say that it is full. Adding an element to a
full mvar will block until one is taken. Taking an element from an
empty mvar will block until one is added.
</p><p>Mailbox variables are commonly used to pass messages between threads.
</p><p>Note that a mailbox variable can be seen as a pushable stream with a
limited memory.
</p><h2> Running a Lwt program </h2><p>Threads you create with <span class="teletype">Lwt</span> always have the type
<span class="teletype">Lwt.t</span>. If you want to write a program and run it this is not
enough. Indeed you don't know when a <span class="teletype">Lwt</span> thread is terminated.
</p><p>For example if your program is just:
</p><pre class=""><code class="language-ocaml translatable">let _ = Lwt_io.printl &quot;Hello, world!&quot;</code></pre><p>you have no guarantee that the thread writing <span class="teletype">&quot;Hello, world!&quot;</span>
on the terminal will be terminated when the program exit. In order
to wait for a thread to terminate, you have to call the function
<span class="teletype">Lwt_main.run</span>:
</p><pre class=""><code class="language-ocaml translatable">val Lwt_main.run : 'a Lwt.t -&gt; 'a</code></pre><p>This functions wait for the given thread to terminate and returns
its result. In fact it does more than that; it also runs the
scheduler which is responsible for making threads progress when
events are received from the outside world.
</p><p>So basically, when you write a <span class="teletype">Lwt</span> program you must call
the toplevel the function <span class="teletype">Lwt_main.run</span>. For instance:
</p><pre class=""><code class="language-ocaml translatable">let () = Lwt_main.run (Lwt_io.printl &quot;Hello, world!&quot;)</code></pre><p>Note that you must call <span class="teletype">Lwt_main.run</span> only once at a time. It
cannot be used anywhere to get the result of a thread. It must only
be used in the entry point of your program.
</p><h2> The <span class="teletype">lwt.unix</span> library </h2><p>The package <span class="teletype">lwt.unix</span> contains all <span class="teletype">unix</span> dependent
modules of <span class="teletype">Lwt</span>. Among all its features, it implements cooperative
versions of functions of the standard library and the unix library.
</p><h3> Unix primitives </h3><p>The <span class="teletype">Lwt_unix</span> provides cooperative system calls. For example,
the <span class="teletype">Lwt</span> counterpart of <span class="teletype">Unix.read</span> is:
</p><pre class=""><code class="language-ocaml translatable">val read : file_descr -&gt; string -&gt; int -&gt; int -&gt; int Lwt.t</code></pre><p><span class="teletype">Lwt_io</span> provides features similar to buffered channels of
the standard library (of type <span class="teletype">in_channel</span> or
<span class="teletype">out_channel</span>) but cooperatively.
</p><p><span class="teletype">Lwt_gc</span> allows you to register a finaliser that returns a
thread. At the end of the program, <span class="teletype">Lwt</span> will wait for all the
finaliser to terminate.
</p><h3> The Lwt scheduler </h3><p>Threads doing IO may be put to sleep until some events are received by
the process. For example when you read from a file descriptor, you
may have to wait for the file descriptor to become readable if no
data are immediately available on it.
</p><p><span class="teletype">Lwt</span> contains a scheduler which is responsible for managing
multiple threads waiting for events, and restart them when needed.
This scheduler is implemented by the two modules <span class="teletype">Lwt_engine</span>
and <span class="teletype">Lwt_main</span>. <span class="teletype">Lwt_engine</span> is a low-level module, it
provides signatures for IO multiplexers as well as several builtin
implementations. <span class="teletype">Lwt</span> supports by default multiplexing IO with
<span class="teletype">libev</span> or <span class="teletype">Unix.select</span>. The signature is given by the
class <span class="teletype">Lwt_engine.t</span>.
</p><p><span class="teletype">libev</span> is used by default on Unix, because it supports any
number of file descriptors while Unix.select supports only 1024 at
most, and is also much more efficient. On Windows <span class="teletype">Unix.select</span>
is used because <span class="teletype">libev</span> does not work properly. The user may
change at any time the backend in use.
</p><p>If you see an <span class="teletype">Invalid_argument</span> error on <span class="teletype">Unix.select</span>, it
may be because the 1024 file descriptor limit was exceeded. Try
switching to <span class="teletype">libev</span>, if possible.
</p><p>The engine can also be used directly in order to integrate other
libraries with <span class="teletype">Lwt</span>. For example <span class="teletype">GTK</span> needs to be notified
when some events are received. If you use <span class="teletype">Lwt</span> with <span class="teletype">GTK</span>
you need to use the <span class="teletype">Lwt</span> scheduler to monitor <span class="teletype">GTK</span>
sources. This is what is done by the <span class="teletype">lwt.glib</span> package.
</p><p>The <span class="teletype">Lwt_main</span> module contains the <em>main loop</em> of
<span class="teletype">Lwt</span>. It is run by calling the function <span class="teletype">Lwt_main.run</span>:
</p><pre class=""><code class="language-ocaml translatable">val Lwt_main.run : 'a Lwt.t -&gt; 'a</code></pre><p>This function continously runs the scheduler until the thread passed
as argument terminates.
</p><p>To make sure <span class="teletype">Lwt</span> is compiled with <span class="teletype">libev</span> support,
tell opam that the library is available on the system by installing the
<a href="http://opam.ocaml.org/packages/conf-libev/conf-libev.4-11/" class="ocsimore_phrasing_link">conf-libev</a>
package. You may get the actual library with your system package manager:
</p><ul><li> <span class="teletype">brew install libev</span> on MacOSX,
</li><li> <span class="teletype">apt-get install libev-dev</span> on Debian/Ubuntu, or
</li><li> <span class="teletype">yum install libev-devel</span> on CentOS, which requires to set
<span class="teletype">export C_INCLUDE_PATH=/usr/include/libev/</span> and
<span class="teletype">export LIBRARY_PATH=/usr/lib64/</span> before calling
<span class="teletype">opam install conf-libev</span>.
</li></ul><h3> The logging facility </h3><p>The package <span class="teletype">lwt.unix</span> contains a module <span class="teletype">Lwt_log</span>
providing loggers. It supports logging to a file, a channel, or to the
syslog daemon. You can also define your own logger by providing the
appropriate functions (function <span class="teletype">Lwt_log.make</span>).
</p><p>Several loggers can be merged into one. Sending logs on the merged
logger will send these logs to all its components.
</p><p>For example to redirect all logs to <span class="teletype">stderr</span> and to the syslog
daemon:
</p><pre class=""><code class="language-ocaml translatable"># Lwt_log.default :=
    Lwt_log.broadcast [
      Lwt_log.channel ~close_mode:`Keep ~channel:Lwt_io.stderr ();
      Lwt_log.syslog ~facility:`User ();
    ]
;;</code></pre><p><span class="teletype">Lwt</span> also provides a syntax extension, in the package
<span class="teletype">lwt.syntax.log</span>. It does not modify the language but
it replaces log statements of the form:
</p><pre class=""><code class="language-ocaml translatable">Lwt_log.info_f ~section &quot;something happened: %s&quot; msg</code></pre><p>by:
</p><pre class=""><code class="language-ocaml translatable">if Lwt_log.Section.level section &lt;= Lwt_log.Info then
  Lwt_log.info_f ~section &quot;something happened: %s&quot; msg
else
  Lwt.return ()</code></pre><p>The advantages of using the syntax extension are the following:
</p><ul><li> it checks the log level before calling the logging function, so
the arguments are not computed if not needed
</li><li> debugging logs can be removed at parsing time
</li></ul><p>By default, the syntax extension removes all logs with the level
<span class="teletype">debug</span>. To keep them, pass the command line option
<span class="teletype">-lwt-debug</span> to camlp4.
</p><h2> The Lwt.react library </h2><p>The <span class="teletype">Lwt_react</span> module provides helpers for using the <span class="teletype">react</span>
library with <span class="teletype">Lwt</span>. It extends the <span class="teletype">React</span> module by adding
<span class="teletype">Lwt</span> specific functions. It can be used as a replacement of
<span class="teletype">React</span>. For example you can add at the beginning of your
program:
</p><pre class=""><code class="language-ocaml translatable">open Lwt_react</code></pre><p>instead of:
</p><pre class=""><code class="language-ocaml translatable">open React</code></pre><p>or:
</p><pre class=""><code class="language-ocaml translatable">module React = Lwt_react</code></pre><p>Among the added functionalities we have <span class="teletype">Lwt_react.E.next</span>, which
takes an event and returns a thread which will wait until the next
occurence of this event. For example:
</p><pre class=""><code class="language-ocaml translatable"># open Lwt_react;;
# let event, push = E.create ();;
val event : '_a React.event = &lt;abstr&gt;
val push : '_a -&gt; unit = &lt;fun&gt;
# let t = E.next event;;
val t : '_a Lwt.t = &lt;abstr&gt;
# Lwt.state t;;
- : '_a Lwt.state = Lwt.Sleep
# push 42;;
- : unit = ()
# Lwt.state t;;
- : int Lwt.state = Lwt.Return 42</code></pre><p>Another interesting feature is the ability to limit events
(resp. signals) from occurring (resp. changing) too often. For example,
suppose you are doing a program which displays something on the screeen
each time a signal changes. If at some point the signal changes 1000
times per second, you probably don't want to render it 1000 times per
second. For that you use <span class="teletype">Lwt_react.S.limit</span>:
</p><pre class=""><code class="language-ocaml translatable">val limit : (unit -&gt; unit Lwt.t) -&gt; 'a React.signal -&gt; 'a React.signal</code></pre><p><span class="teletype">Lwt_react.S.limit f signal</span> returns a signal which varies as
<span class="teletype">signal</span> except that two consecutive updates are separated by a
call to <span class="teletype">f</span>. For example if <span class="teletype">f</span> returns a thread which sleeps
for 0.1 seconds, then there will be no more than 10 changes per
second. For example:
</p><pre class=""><code class="language-ocaml translatable">open Lwt_react

let draw x =
  (* Draw the screen *)
  ...

let () =
  (* The signal we are interested in: *)
  let signal = ... in

  (* The limited signal: *)
  let signal' = S.limit (fun () -&gt; Lwt_unix.sleep 0.1) signal in

  (* Redraw the screen each time the limited signal change: *)
  S.notify_p draw signal'</code></pre><h2> Other libraries </h2><h3> Detaching computation to preemptive threads </h3><p>It may happen that you want to run a function which will take time to
compute or that you want to use a blocking function that cannot be
used in a non-blocking way. For these situations, <span class="teletype">Lwt</span> allows you to
<em>detach</em> the computation to a preemptive thread.
</p><p>This is done by the module <span class="teletype">Lwt_preemptive</span> of the
<span class="teletype">lwt.preemptive</span> package which maintains a pool of system
threads. The main function is:
</p><pre class=""><code class="language-ocaml translatable">val detach : ('a -&gt; 'b) -&gt; 'a -&gt; 'b Lwt.t</code></pre><p><span class="teletype">detach f x</span> will execute <span class="teletype">f x</span> in another thread and
asynchronously wait for the result.
</p><p>If you have to run <span class="teletype">Lwt</span> code in another thread, you must use
the function <span class="teletype">Lwt_preemptive.run_in_main</span>:
</p><pre class=""><code class="language-ocaml translatable">val run_in_main : (unit -&gt; 'a Lwt.t) -&gt; 'a</code></pre><p>It works as follow:
</p><ul><li> it sends the function to the main thread and wait
</li><li> the main thread execute the function
</li><li> when it terminates the main thread sends back the result
</li><li> the result is returned
</li></ul><p>Note that you cannot call <span class="teletype">Lwt_main.run</span> in another system
thread, so you must use this function.
</p><h3> SSL support </h3><p>The package <span class="teletype">lwt.ssl</span> provides the module <span class="teletype">Lwt_ssl</span>
which allows use of SSL asynchronously.
</p><h3> Glib integration </h3><p>The <span class="teletype">lwt.glib</span> embeds the <span class="teletype">glib</span> main loop into the
<span class="teletype">Lwt</span> one. This allows you to write GTK applications using <span class="teletype">Lwt</span>.  The
one thing you have to do is to call <span class="teletype">Lwt_glib.install</span> at
the beginning of your program.
</p><h2> Writing stubs using <span class="teletype">Lwt</span> </h2><h3> Thread-safe notifications </h3><p>If you want to notify the main thread from another thread, you can use the <span class="teletype">Lwt</span>
thread safe notification system. First you need to create a notification identifier
(which is just an integer) from the OCaml side using the
<span class="teletype">Lwt_unix.make_notification</span> function, then you can send it from either the
OCaml code with <span class="teletype">Lwt_unix.send_notification</span> function, or from the C code using
the function <span class="teletype">lwt_unix_send_notification</span> (defined in <span class="teletype">lwt_unix_.h</span>).
</p><p>Notifications are received and processed asynchronously by the main thread.
</p><h3> Jobs </h3><p>For operations that cannot be executed asynchronously, <span class="teletype">Lwt</span>
uses a system of jobs that can be executed in a different threads. A
job is composed of three functions:
</p><ul><li> A stub function to create the job. It must allocate a new job
structure and fill its [worker] and [result] fields. This
function is executed in the main thread.
The return type for the OCaml external must be of the form <span class="teletype">'a job</span>.
</li><li> A function which executes the job. This one may be executed asynchronously
in another thread. This function must not:
<ul><li> access or allocate OCaml block values (tuples, strings, ...),
</li><li> call OCaml code.
</li></ul></li><li> A function which reads the result of the job, frees resources and
returns the result as an OCaml value. This function is executed in
the main thread.
</li></ul><p>With <span class="teletype">Lwt &lt; 2.3.3</span>, 4 functions (including 3 stubs) were
required. It is still possible to use this mode but it is
deprecated.
</p><p>We show as example the implementation of <span class="teletype">Lwt_unix.mkdir</span>. On the C
side we have:
</p><pre class="manually-translated"><code class="language-c">/**/
/* Structure holding informations for calling [mkdir]. */
struct job_mkdir {
  /* Informations used by lwt.
     It must be the first field of the structure. */
  struct lwt_unix_job job;
  /* This field store the result of the call. */
  int result;
  /* This field store the value of [errno] after the call. */
  int errno_copy;
  /* Pointer to a copy of the path parameter. */
  char* path;
  /* Copy of the mode parameter. */
  int mode;
  /* Buffer for storing the path. */
  char data[];
};

/* The function calling [mkdir]. */
static void worker_mkdir(struct job_mkdir* job)
{
  /* Perform the blocking call. */
  job-&gt;result = mkdir(job-&gt;path, job-&gt;mode);
  /* Save the value of errno. */
  job-&gt;errno_copy = errno;
}

/* The function building the caml result. */
static value result_mkdir(struct job_mkdir* job)
{
  /* Check for errors. */
  if (job-&gt;result &lt; 0) {
    /* Save the value of errno so we can use it
       once the job has been freed. */
    int error = job-&gt;errno_copy;
    /* Copy the contents of job-&gt;path into a caml string. */
    value string_argument = caml_copy_string(job-&gt;path);
    /* Free the job structure. */
    lwt_unix_free_job(&amp;job-&gt;job);
    /* Raise the error. */
    unix_error(error, &quot;mkdir&quot;, string_argument);
  }
  /* Free the job structure. */
  lwt_unix_free_job(&amp;job-&gt;job);
  /* Return the result. */
  return Val_unit;
}

/* The stub creating the job structure. */
CAMLprim value lwt_unix_mkdir_job(value path, value mode)
{
  /* Get the length of the path parameter. */
  mlsize_t len_path = caml_string_length(path) + 1;
  /* Allocate a new job. */
  struct job_mkdir* job =
    (struct job_mkdir*)lwt_unix_new_plus(struct job_mkdir, len_path);
  /* Set the offset of the path parameter inside the job structure. */
  job-&gt;path = job-&gt;data;
  /* Copy the path parameter inside the job structure. */
  memcpy(job-&gt;path, String_val(path), len_path);
  /* Initialize function fields. */
  job-&gt;job.worker = (lwt_unix_job_worker)worker_mkdir;
  job-&gt;job.result = (lwt_unix_job_result)result_mkdir;
  /* Copy the mode parameter. */
  job-&gt;mode = Int_val(mode);
  /* Wrap the structure into a caml value. */
  return lwt_unix_alloc_job(&amp;job-&gt;job);
}</code></pre><p>and on the ocaml side:
</p><pre class=""><code class="language-ocaml translatable">(* The stub for creating the job. *)
external mkdir_job : string -&gt; int -&gt; unit job = &quot;lwt_unix_mkdir_job&quot;

(* The ocaml function. *)
let mkdir name perms = Lwt_unix.run_job (mkdir_job name perms)</code></pre></article></div></div></body></html>
